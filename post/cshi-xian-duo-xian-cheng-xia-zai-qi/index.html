<html>
  <head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>c++实现多线程下载器 | dr526</title>
<link rel="shortcut icon" href="https://dr526.github.io//favicon.ico?v=1602046645180">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://dr526.github.io//styles/main.css">

<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/moment.js/2.23.0/moment.min.js"></script>



  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://dr526.github.io/">
  <img class="avatar" src="https://dr526.github.io//images/avatar.png?v=1602046645180" alt="">
  </a>
  <h1 class="site-title">
    dr526
  </h1>
  <p class="site-description">
    十步one code，千里no bug
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>


        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              c++实现多线程下载器
            </h2>
            <div class="post-info">
              <time class="post-time">
                · 2020-10-05 ·
              </time>
              
                <a href="https://dr526.github.io/tag/rkgvoQhuF/" class="post-tag">
                  # c++
                </a>
              
            </div>
            
            <div class="post-content">
              <h1 id="多线程下载原理">多线程下载原理</h1>
<p>对于一个指定长度的文件F，假如它的长度为L，若需要n个线程来来下载。有两种情况需要考虑：</p>
<ol>
<li>
<p>当L%n==0时</p>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20201005112348276.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzI2NzQ0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" loading="lazy"></figure>
</li>
<li>
<p>当L%n!=0时</p>
</li>
</ol>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/20201005112406979.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzI2NzQ0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" loading="lazy"></figure>
<p>注：由于各个线程都是下载文件的不同部分，那么它们请求的时候就该请求文件的不同部分，即：使用http协议中的<strong>范围请求</strong></p>
<h1 id="开发环境配置">开发环境配置</h1>
<ul>
<li>
<p>开发工具：Visual Studio Community 2019 16.7.3</p>
</li>
<li>
<p>第三方库：</p>
<ol>
<li>
<p>libcurl（curl-7.72.0)</p>
<p>配置参考：<a href="https://blog.csdn.net/wanghualin033/article/details/78234474">libcurl库源码编译，安装c++_wanghualin033的博客-CSDN博客</a></p>
<p>我已经编译完成，需要自取：https://wws.lanzous.com/iKOU7h6o4ri</p>
</li>
<li>
<p>osapi</p>
<p>配置参考：<a href="https://blog.csdn.net/qq_43326744/article/details/108760582">c++导入第三方库_qq_43326744的博客-CSDN博客</a></p>
<p>下载地址：<a href="https://wws.lanzous.com/iLLplgu3aih">osapi.rar - 蓝奏云 (lanzous.com)</a></p>
</li>
</ol>
</li>
</ul>
<h1 id="程序设计">程序设计</h1>
<ul>
<li>
<p>完整项目下载地址：<a href="https://wws.lanzous.com/ifRHPh6p8cd">下载</a></p>
</li>
<li>
<p>主要框架图</p>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/20201005112538843.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzI2NzQ0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" loading="lazy"></figure>
</li>
<li>
<p>主线程</p>
<ol>
<li>
<p>获取文件长度</p>
<pre><code class="language-c++">/**
    要下载文件的大小
**/
long getDownloadFileLenth(const char* url)
{
    double downloadFileLenth = 0;
    CURL* handle = curl_easy_init();
    curl_easy_setopt(handle, CURLOPT_URL, url);
    curl_easy_setopt(handle, CURLOPT_HEADER, 1);	//只需要header头
    curl_easy_setopt(handle, CURLOPT_NOBODY, 1);	//不需要body
    if (curl_easy_perform(handle) == CURLE_OK)
    {
        curl_easy_getinfo(handle, CURLINFO_CONTENT_LENGTH_DOWNLOAD, &amp;downloadFileLenth);
    }
    else
    {
        downloadFileLenth = -1;
    }
    return downloadFileLenth;
}
</code></pre>
</li>
<li>
<p>线程分配</p>
<pre><code class="language-c++">       long fileLength = getDownloadFileLenth(url);
        long partSize = fileLength / threadNum;
        //计算每个线程负责的大小
        for (int i = 0; i &lt;= threadNum; ++i) {
            tNode* tnode = new tNode;
            if (i &lt; threadNum) {
                tnode-&gt;startPos = i * partSize;
                tnode-&gt;endPos = (i + 1) * partSize - 1;
            }
            else {
                if (fileLength % threadNum != 0) {
                    tnode-&gt;startPos = i * partSize;
                    tnode-&gt;endPos = fileLength - 1;
                }
                else
                    break;
            }
            tnode-&gt;curl = curl_easy_init();
            tnode-&gt;fp = fp;
            tnode-&gt;id = i;
            downLoad(url, tnode);
            DownThread* task = new DownThread(tnode);
            task-&gt;start();
</code></pre>
<pre><code class="language-c++">/**
    文件下载的准备工作
**/
void downLoad(char* url,tNode* tnode) {
    char progress_data[3] = &quot;* &quot;;
    char range[64] = { 0 };
    snprintf(range, sizeof(range), &quot;%ld-%ld&quot;, tnode-&gt;startPos, tnode-&gt;endPos);
    if (tnode-&gt;curl)
    {
        //设置请求路径
        curl_easy_setopt(tnode-&gt;curl, CURLOPT_URL, url);

        //允许跳转
        curl_easy_setopt(tnode-&gt;curl, CURLOPT_FOLLOWLOCATION, 1);
        curl_easy_setopt(tnode-&gt;curl, CURLOPT_SSL_VERIFYPEER, FALSE);
        curl_easy_setopt(tnode-&gt;curl, CURLOPT_SSL_VERIFYHOST, FALSE);

        //写入文件
        curl_easy_setopt(tnode-&gt;curl, CURLOPT_WRITEDATA, tnode);
        curl_easy_setopt(tnode-&gt;curl, CURLOPT_WRITEFUNCTION, curlWriteFunction);

        //设置进度回调
        curl_easy_setopt(tnode-&gt;curl, CURLOPT_NOPROGRESS, FALSE);
        curl_easy_setopt(tnode-&gt;curl, CURLOPT_PROGRESSFUNCTION, my_progress_func);
        curl_easy_setopt(tnode-&gt;curl, CURLOPT_PROGRESSDATA, &amp;tnode-&gt;id);

        //设置范围请求
        curl_easy_setopt(tnode-&gt;curl, CURLOPT_NOSIGNAL, 1L);
        curl_easy_setopt(tnode-&gt;curl, CURLOPT_LOW_SPEED_LIMIT, 1L);
        curl_easy_setopt(tnode-&gt;curl, CURLOPT_LOW_SPEED_TIME, 5L);
        curl_easy_setopt(tnode-&gt;curl, CURLOPT_RANGE, range);
    }
}

</code></pre>
<pre><code class="language-c++">/**
    将数据写入文件中
**/
size_t curlWriteFunction(void* ptr, size_t size, size_t nmemb, tNode* tnode)
{
    //ptr指向待下载数据，size为被写入每个元素的大小，大小为字节，nmemb是元素个数，大小为size字节
    size_t written = 0;
    mutex.Lock();
    if (tnode-&gt;startPos + size * nmemb &lt;= tnode-&gt;endPos) {
        fseek(tnode-&gt;fp, tnode-&gt;startPos, SEEK_SET);
        written = fwrite(ptr, size, nmemb, tnode-&gt;fp);
        tnode-&gt;startPos += size * nmemb;
    }
    else {
        fseek(tnode-&gt;fp, tnode-&gt;startPos, SEEK_SET);
        written = fwrite(ptr, 1, tnode-&gt;endPos - tnode-&gt;startPos + 1, tnode-&gt;fp);
        tnode-&gt;startPos = tnode-&gt;endPos;
    }
    mutex.Unlock();
    return written;
}

/**
    显示文件下载进度
**/
int my_progress_func(int* progress_data,
    double t, /* 下载数据大小 */
    double d, /* 当前已经下载大小 */
    double ultotal,
    double ulnow)
{
    printf_s(&quot;当前线程为：%d %g / %g (%g %%)\n&quot;, *progress_data, d, t, d * 100.0 / t);
    return 0;
}
</code></pre>
</li>
</ol>
</li>
<li>
<p>下载线程</p>
<pre><code class="language-c++">#pragma once
#include&quot;osapi/osapi.h&quot;
#include&quot;tNode.h&quot;
#include&lt;iostream&gt;
using namespace std;
class DownThread :public OS_Thread {
public:
    DownThread(tNode* tnode) :tnode(tnode) {
        id = tnode-&gt;id;
        alive = false;
    }
    bool getAlive()const {
        return this-&gt;alive;
    }
    void start() {
        Run();
        alive = true;
    }
    int getId() {
        return id;
    }
private:
    virtual int Routine() {
        int res = curl_easy_perform(tnode-&gt;curl);
        if (res != 0) {
            cout &lt;&lt; &quot;下载出错&quot; &lt;&lt; endl;
        }
        curl_easy_cleanup(tnode-&gt;curl);
        this-&gt;alive = false;
        delete tnode;
        return 0;
    }
private:
    bool alive;
    tNode* tnode;
    int id;
};
</code></pre>
</li>
<li>
<p>回收管理</p>
<pre><code class="language-c++">//ThreadMonitor.h
#pragma once
#include&quot;osapi/osapi.h&quot;
#include&quot;DownThread.h&quot;
#include&lt;iostream&gt;
#include&lt;list&gt;
using namespace std;
class ThreadMonitor :public OS_Thread
{
public:
	//单例模式
	static ThreadMonitor* object();
private:
	ThreadMonitor(){}
	~ThreadMonitor(){}
public:
	void start();
	void stop();
	void monitor(DownThread* task);
private:
	virtual int Routine();
private:
	list&lt;DownThread*&gt;tasks;//线程的列表
	bool quit_flag;
	OS_Mutex mutex;
};
</code></pre>
<pre><code class="language-c++">//ThreadMonitor.cpp
#include &quot;ThreadMonitor.h&quot;

//单例模式的实现
ThreadMonitor* ThreadMonitor::object() {
	static ThreadMonitor only;
	return &amp;only;
}

void ThreadMonitor::start() {
	quit_flag = false;
	Run();
}

void ThreadMonitor::stop() {
	quit_flag = false;
	Join(this);
}

void ThreadMonitor::monitor(DownThread* task) {
	mutex.Lock();
	tasks.push_back(task);
	mutex.Unlock();
}

int ThreadMonitor::Routine() {
	while (!quit_flag) {
		mutex.Lock();
		//遍历tasks，找到已经完成的线程并回收
		for (auto iter = tasks.begin(); iter != tasks.end();) {
			DownThread* task = *iter;
			if (task-&gt;getAlive())++iter;
			else {
				cout &lt;&lt; &quot;已经回收DownThread：&quot; &lt;&lt; task-&gt;getId() &lt;&lt; endl;
				iter = tasks.erase(iter);
				Join(task);
				delete(task);
			}
		}
		mutex.Unlock();
		OS_Thread::Sleep(1);
	}
	return 0;
}
</code></pre>
</li>
<li>
<p>其他</p>
<pre><code class="language-c++">//tNode.h
#pragma once
#include &lt;cstdio&gt;
#include &lt;curl\curl.h&gt;
#pragma comment(lib,&quot;libcurl-d_imp.lib&quot;)
struct tNode
{
    int id;
    FILE* fp;
    long startPos;
    long endPos;
    CURL* curl;
};
</code></pre>
</li>
</ul>
<h1 id="运行结果">运行结果</h1>
<pre><code class="language-c++">char fileName[50] = &quot;TIM.exe&quot;;//保存路径，在当前项目目录下
char url[128] = &quot;https://dldir1.qq.com/qqfile/qq/PCTIM/TIM3.2.0/TIM3.2.0.21856.exe&quot;;//下载路径
int threadNum = 36;//要使用的线程数量
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://img-blog.csdnimg.cn/20201005112601581.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzI2NzQ0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" loading="lazy"></figure>
<figure data-type="image" tabindex="5"><img src="https://img-blog.csdnimg.cn/20201005112612771.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzI2NzQ0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" loading="lazy"></figure>

            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://dr526.github.io/post/c-tcp-xiang-guan-ji-yu-osapi/">
              <h3 class="post-title">
                c++ TCP相关——基于OSAPI
              </h3>
            </a>
          </div>
        

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '',
    clientSecret: '',
    repo: '',
    owner: '',
    admin: [''],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | 
  <a class="rss" href="https://dr526.github.io//atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>

      </div>
    </div>
  </body>
</html>
